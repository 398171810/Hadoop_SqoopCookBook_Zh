<h2>使用自定义边界查询</h2>

<h3>问题</h3>
你发现free-form查询导入对你的用例非常有用。但不幸的是在MapReduce中启动任何数据传输之前, Sqoop需要很
长时间才能获取针对绑定 **--split-by**参数列，所需要的最大和最小的用于分片传输的任务数。

<h3>解决方案</h3>

为了将数据分区到多个独立的切片中, 将在并行方式传输。sqoop需要被绑定**--split-by**参数列的最大值和最小
指。在基于表的导入中，sqoop通过表的默认通过主键生成最大和最小的值查询 : 
SELECT min(col) , max(col) from tabl。

在free-query查询导入的情况下, Sqoop不可从表中获取获取最大和最小。相反,sqoop需要在命令中一个使用子查询
来获取这些值。这样的查询非常效率低下, 因为它需要在在任何实质性数据输出之前进处理，为了使获取导入数据的
边界。

在不了解查询和基础数据的情况下, Sqoop可以自动优化的不多。sqoop提供参数 **--boudary-query**,通过这个参
数，查询可以从新生成数据。对于这个参数，只需要的返回两行数据，最小的行和最大的行。第一列将被视为下界, 而
第二列将上界，这两个值都是包含的被导入。两者的类型都必须与被绑定**--split-by**的列类型相同。

了解数据和查询的目的使您可以轻松地识别主表,但前提是只有一张表，并且从这张表选择边界的时候并没有关关联其
他的表。用于获取查询的边界可以是任意的,举一些例子说明：如果你在执行sqoop前你已经执行的数据的边界，可以
在查询中限定边界而不需要使用从新打开表来使用像 select 1,5000这样的语句来限定边界。

如果最大和最小的值存储在不同的表中为了审计的目的，同样可以这些表中获取数据。没有任何必要将在 
**--query**命令的表引用到**--boudry-query**命令中，由于使用边界查询的数据将是作为基础导入数据。
当然导入处理的数据要和输出的数据要吻合是不可避免的。
