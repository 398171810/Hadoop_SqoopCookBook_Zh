<h2>5.3对语义的导出</h2>

<h3>问题</h3>
需要确保Sqoop可以将Hadoop中的所有数据导出到数据库中, 或者不导出任何数据(也就是说, 目标表将保持为空)。

<h3>解决方案</h3>
在对实际表进行更改之前, 可以使用临时表先将数据加载到临时表中。临时表名称是通过**--staging-table**参数指定的,在下面的示例中, 我们将其设置为 staging_cities:

```
sqoop export \
--connect jdbc:mysql://mysql.example.com/sqoop \
--username sqoop \
--password sqoop \
--table cities \
--staging-table staging_cities
```

<h3>讨论</h3>
使用临时表时, Sqoop 将首先将所有数据导出到此临时表中, 而不是参数表中存在的主表。如果且仅当所有并行任务成功传输数据, Sqoop 将打开一个新事务, 以便
将数据从临时表移动到最终目标。一方面, 此方法保证了导出操作的全部或全部语义, 但也暴露了数据库端的其他限制。

由于 Sqoop 将将数据导出到临时表中, 然后将其移动到最后一个表中, 因此有一段时间内, 所有数据都存储在数据库中两次 (临时表中的一个副本和最后一个表中的
一个拷贝)。为了使用此方法, 系统上必须有足够的可用空间来容纳两个副本。由于数据首先加载位置, 然后移到最后一个表中, 所以使用临时表总是比直接导出到最
终表的速度慢。

Sqoop 要求临时表的结构与目标表的构造相同。列数及其类型必须相同;否则,导出操作将失败。其他特性没有强制执行, 因为Sqoop使用户能够利用高级数据库功能。
可以将临时表存储在不同的逻辑数据库 (在同一物理框中) 或其他文件组中。某些扩展属性不会对 Sqoop 产生影响: 目标表可能已分区, 而临时表可能不存在, 或者
两个表都可能使用不同的存储引擎。

临时表不是由 Sqoop 自动创建的, 必须在启动导出过程之前存在。此外, 它需要是空的, 以便以一致的数据结束。可以指定参数--清除临时表以指示 Sqoop 自动清
除临时表。如果数据库支持, Sqoop将使用截断操作尽快清理临时表


